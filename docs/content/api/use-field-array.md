---
title: useFieldArray
description: API reference for the useFieldArray composition API function
menuTitle: useFieldArray()
order: 7
---

# useFieldArray <DocBadge title="v4.5" />

`useFieldArray` is a custom composition API function that allows you to manage repeatable fields and forms entries and provides common operation helpers.

Basic usage:

```vue
<template>
  <form @submit="onSubmit" novalidate>
    <div v-for="(field, idx) in fields" :key="field.key">
      <Field :name="`links[${idx}].url`" type="url" />

      <button type="button" @click="remove(idx)">Remove</button>
    </div>

    <button type="button" @click="push({ url: '' })">Add</button>

    <button>Submit</button>
  </form>
</template>

<script>
import { Field, useForm, useFieldArray } from 'vee-validate';

export default {
  components: {
    Field,
  },
  setup() {
    const { handleSubmit } = useForm({
      initialValues: {
        links: [{ id: 1, url: 'https://github.com/logaretm' }],
      },
    });

    const { remove, push, fields } = useFieldArray({
      // This can be a reactive refs
      name: 'links',
    });

    const onSubmit = handleSubmit(values => {
      console.log(JSON.stringify(values, null, 2));
    });

    return {
      fields,
      push,
      remove,
      onSubmit,
    };
  },
};
</script>
```

## API Reference

The full signature of the `useFieldArray` function looks like this:

```ts
interface FieldEntry<TValue = unknown> {
  value: Ref<TValue>;
  key: string | number;
  isFirst: boolean;
  isLast: boolean;
}

interface FieldArrayContext<TValue = unknown> {
  fields: DeepReadonly<Ref<FieldEntry[]>>;
  remove(idx: number): TValue | undefined;
  push(value: TValue): void;
  swap(indexA: number, indexB: number): void;
  insert(idx: number, value: TValue): void;
}

interface FieldArrayOptions {
  name: Ref<string> | string;
  keyPath: Ref<string> | string;
}

function useFieldArray: (opts: FieldArrayOptions): FieldArrayContext;
```

### Composable API

The following sections documents each available property on the `useFieldArray` composable.

<code-title level="4">

`fields: Ref<FieldArrayEntry<TValue>[]>`

</code-title>

This is a **read-only** version of your array items, wrapped inside a `FieldArrayEntry` object which has the following interface:

```ts
interface FieldEntry<TValue = unknown> {
  // The actual value of the item as readonly, this is what exists in the form values
  value: Ref<TValue>;
  // a value you can use as a key for iteration, generated by `key-path` prop
  key: string | number;
  // true if this is the first array item
  isFirst: boolean;
  // true if this is the last array item
  isLast: boolean;
}
```

<code-title level="4">

`push(item: any)`

</code-title>

Adds an item to the end of the array.

```js
const { push, fields } = useFieldArray({
  name: 'links',
});

// adds a new item to the array
push({ url: '' });
```

<code-title level="4">

`remove(idx: number)`

</code-title>

Removes the item at the specified index from the array if it exists.

```js
const { remove, fields } = useFieldArray({
  name: 'links',
});

// removes the second item from the array
remove(1);
```

<code-title level="4">

`swap(idxA: number, idxB: number)`

</code-title>

Swaps the items at the given indexes with each other. Both indexes must exist in the array or it won't have an effect.

```js
const { swap, fields } = useFieldArray({
  name: 'links',
});

// Swaps the 4th item with the 5th
swap(3, 4);
```

<code-title level="4">

`insert(idx: number, item: any)`

</code-title>

Adds an item at the specified index. If the specified index will place the item out of bounds (i.e: larger than length) the operation will be ignored.

```js
const { insert, fields } = useFieldArray({
  name: 'links',
});

// inserts a new item to the array at the second index
insert(1, { url: '' });
```
